(include "sys/func.inc")
(include "gui/path/class.inc")
(include "class/list/class.inc")
(include "sys/math/class.inc")

(def-method 'path :stroke_polylines)
	;inputs
	;r0 = output list of path objects (ptr)
	;r1 = stack array object (ptr)
	;r2 = input list of path objects (ptr)
	;r3 = radius (fixed)
	;r4 = tolerance (fixed)
	;r5 = join style (byte)
	;r6 = cap style1 (byte)
	;r7 = cap style2 (byte)
	;outputs
	;r0 = output list of path objects (ptr)
	;trashes
	;r1-r14

	(union
		(ulong 'p1 'p2 'p3 'p4 'l2_v 'l2_pv 'l2_npv 'l2_rv 'l1_v 'l1_npv 'l1_rv)
		(int 'p1x 'p1y 'p2x 'p2y 'p3x 'p3y 'p4x 'p4y
			'l2_vx 'l2_vy 'l2_pvx 'l2_pvy 'l2_npvx 'l2_npvy 'l2_rvx 'l2_rvy
			'l1_vx 'l1_vy 'l1_npvx 'l1_npvy 'l1_rvx 'l1_rvy))
	(plong 'iter 'iter_begin 'iter_end)
	(pptr 'iter_begin_polylines 'iter_end_polylines)
	(ptr 'this 'stack 'out_points)
	(int 'radius 'eps 'step 'c 'c1)
	(byte 'join_style 'cap1_style 'cap2_style)

	(push-scope)
	(used-syms 'l2_pv 'p3 'p4)
	(entry 'path :stroke_polylines {this, stack, iter_end_polylines, radius, eps, join_style, cap1_style, cap2_style})

	(vpif {radius >= 0.5})
		(vec-set 0)
		(call 'list :get_both {iter_end_polylines} {_, iter_begin_polylines, iter_end_polylines})
		(loop-while {iter_begin_polylines /= iter_end_polylines})
			(assign {*iter_begin_polylines} {iter_begin})
			(call 'path :filter_polyline {iter_begin, iter_begin, 0.5})
			(call 'path :get_both {iter_begin} {_, iter, iter_end})
			(vpif {iter_end - iter >= 4 * ptr_size})
				(call 'path :create nil {out_points})
				(assign {iter - (2 * long_size), (2 * long_size)} {iter_begin, step})
				(loop-start)
					(assign {iter[0]} {p1x})
					(assign {iter[long_size]} {p1y})
					(assign {iter + step} {iter})
					(assign {iter[0]} {p2x})
					(assign {iter[long_size]} {p2y})
					(assign {iter + step} {iter})
					(vec-load 2 {p2x, p2y} {p1x, p1y})
					(vec-sub 2)
					(vec-tee 2 {l2_vx, l2_vy})
					(vec-perp)
					(vec-tee 2 {l2_pvx, l2_pvy})
					(vec-fnorm 2)
					(vec-tee 2 {l2_npvx, l2_npvy})
					(vec-load 1 {radius})
					(vec-fscale 2)
					(vec-store 2 {l2_rvx, l2_rvy})

					(vpif {step > 0})
						(assign {cap1_style} {c})
					(else)
						(assign {cap2_style} {c})
					(endif)
					(switch)
					(vpcase {c = cap_butt})
						;butt cap
						(vec-load 2 {p1x, p1y})
						(vec-goto 'out_cap)
					(vpcase {c = cap_square})
						;square cap
						(vec-load 2 {p1x, p1y} {l2_rvx, l2_rvy})
						(vec-perp)
						(vec-add 2)
					(vp-label 'out_cap)
						(vec-load 2 {l2_rvx, l2_rvy})
						(vec-dup 4)
						(vec-sub 2)
						(vec-goto 'store_p3p4)
					(vpcase {c = cap_tri})
						;triangle cap
						(vec-load 2 {p1x, p1y} {l2_rvx, l2_rvy})
						(vec-dup 4)
						(vec-dup 4)
						(vec-sub 2)
						(vec-store 2 {p1x, p1y})
						(vec-perp)
						(vec-add 2)
						(vec-store 2 {p3x, p3y})
						(vec-add 2)
						(vec-store 2 {p4x, p4y})
						(call 'path :push_back2 {out_points, p1x, p1y})
						(goto 'out_p3p4)
					(vpcase {c = cap_arrow})
						;arrow cap
						(vec-load 2 {l2_rvx, l2_rvy})
						(vec-shl 2 1)
						(vec-store 2 {p3x, p3y})
						(vec-load 2 {p1x, p1y} {l2_rvx, l2_rvy})
						(vec-sub 2)
						(vec-store 2 {p4x, p4y})
						(call 'path :push_back2 {out_points, p4x, p4y})
						(vec-load 2 {p1x, p1y} {p3x, p3y})
						(vec-sub 2)
						(vec-store 2 {p4x, p4y})
						(call 'path :push_back2 {out_points, p4x, p4y})
						(vec-load 2 {p1x, p1y} {p3x, p3y})
						(vec-perp)
						(vec-add 2)
						(vec-store 2 {p4x, p4y})
						(call 'path :push_back2 {out_points, p4x, p4y})
						(vec-load 2 {l2_rvx, l2_rvy} {p1x, p1y})
						(vec-dup 2)
						(vec-load 2 {p3x, p3y})
						(vec-add 2)
					(vp-label 'store_p3p4)
						(vec-store 2 {p3x, p3y})
						(vec-add 2)
						(vec-store 2 {p4x, p4y})
					(vp-label 'out_p3p4)
						(call 'path :push_back2 {out_points, p3x, p3y})
						(call 'path :push_back2 {out_points, p4x, p4y})
					(else)
						;round cap
						(vec-load 2 {l2_rvx, l2_rvy})
						(vec-dup 2)
						(vec-perp)
						(vec-store 2 {p3x, p3y})
						(vec-load 1 {-1})
						(vec-scale 2)
						(vec-store 2 {p4x, p4y})
						(call 'path :gen_clerp {out_points, stack, p1x, p1y, p4x, p4y, p3x, p3y, radius, eps})
						(call 'path :gen_clerp {out_points, stack, p1x, p1y, p3x, p3y, l2_rvx, l2_rvy, radius, eps})
					(endswitch)
					(loop-while {iter /= iter_begin && iter /= iter_end})
						(vec-load 4 {p2, l2_v, l2_npv, l2_rv})
						(vec-store 4 {p1, l1_v, l1_npv, l1_rv})
						(assign {iter[0]} {p2x})
						(assign {iter[long_size]} {p2y})
						(assign {iter + step} {iter})
						(vec-load 2 {p2x, p2y} {p1x, p1y})
						(vec-sub 2)
						(vec-tee 2 {l2_vx, l2_vy})
						(vec-perp)
						(vec-tee 2 {l2_pvx, l2_pvy})
						(vec-fnorm 2)
						(vec-tee 2 {l2_npvx, l2_npvy})
						(vec-load 1 {radius})
						(vec-fscale 2)
						(vec-store 2 {l2_rvx, l2_rvy})

						;what kind of join
						(vec-load 2 {l1_npvx, l1_npvy} {l2_npvx, l2_npvy})
						(vec-dup 4)
						(vec-perp)
						(vec-fdot 2)
						(vec-store 1 {c})
						(vec-fdot 2)
						(vec-store 1 {c1})

						(switch)
						(vpcase {(c < 0.01) && (c > -0.01) || (c1 < -0.9)})
							;acuracy limit
							(goto 'do_bevel)
						(vpcase {c <= 0 || join_style = join_miter})
							;mitre join
							(vec-load 2 {p1x, p1y})
							(vec-dup 2)
							(vec-load 4 {l1_rvx, l1_rvy, l2_rvx, l2_rvy})
							(vec-add 4)
							(vec-store 4 {p3x, p3y, p1x, p1y})
							(call 'sys_math :f_intersect {p3x, p3y, p1x, p1y, l1_vx, l1_vy, l2_vx, l2_vy} {p1x, p1y})
							(goto 'out_p1)
						(vpcase {join_style = join_bevel})
						(vp-label 'do_bevel)
							;bevel join
							(vec-load 2 {p1x, p1y})
							(vec-dup 2)
							(vec-load 4 {l1_rvx, l1_rvy, l2_rvx, l2_rvy})
							(vec-add 4)
							(vec-store 4 {p3x, p3y, p1x, p1y})
							(call 'path :push_back2 {out_points, p3x, p3y})
						(vp-label 'out_p1)
							(call 'path :push_back2 {out_points, p1x, p1y})
						(else)
							;rounded join
							(call 'path :gen_clerp {out_points, stack, p1x, p1y, l1_rvx, l1_rvy, l2_rvx, l2_rvy, radius, eps})
						(endswitch)
					(loop-end)
					(breakif {step < 0})
					(assign {-step} {step})
					(assign {iter + step} {iter})
				(loop-end)
				(call 'list :push_back {this, out_points})
			(endif)
			(assign {iter_begin_polylines + ptr_size} {iter_begin_polylines})
		(loop-end)
	(endif)

	(exit 'path :stroke_polylines {this})
	(pop-scope)
	(return)

(def-func-end)
