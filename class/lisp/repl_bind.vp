(include "sys/func.inc")
(include "class/sym/class.inc")
(include "class/hmap/class.inc")
(include "class/func/class.inc")
(include "class/lisp/class.inc")
(include "lib/consts/chars.inc")

(def-method 'lisp :repl_bind)
	;inputs
	;r0 = lisp object (ptr)
	;r1 = form object iter (pptr)
	;outputs
	;r0 = lisp object (ptr)
	;trashes
	;r1-r14

	(def-struct 'local)
		(ptr 'this 'form)
		(pptr 'iter_begin 'iter_end)
		(uint 'start)
	(def-struct-end)

	(entry 'lisp :repl_bind '(r0 r1))

	;a none empty list ?
	(switch)
	(f-bind 'list :vtable r2)
	(assign '((r1 obj_vtable)) '(r3))
	(breakif '(r2 /= r3))
	(assign '((r1 array_length)) '(r2))
	(breakif '(r2 = 0))
	(default)
		;it's a none empty list
		(vp-alloc local_size)
		(assign '((r0 lisp_stack) r0 r1) '(r2 (rsp local_this) (rsp local_form)))
		(assign '((r2 array_length)) '(r2))
		(assign '(r2) '((rsp local_start)))
		(loop-start)
			(class/array/get_both r1 r1 r2)
			(assign '(r1 r2 (r1 0)) '((rsp local_iter_begin) (rsp local_iter_end) r1))

			;first element check for function call
			;is none quoted list ?
			(assign '((r0 lisp_sym_quote)) '(r2))
			(gotoif '(r1 = r2) 'next_list)

			;is it a lambda or macro or not a symbol ?
			(switch)
			(assign '((r0 lisp_sym_lambda)) '(r2))
			(breakif '(r1 = r2))
			(assign '((r0 lisp_sym_macro)) '(r2))
			(breakif '(r1 = r2))
			(f-bind 'sym :vtable r2)
			(assign '((r1 obj_vtable)) '(r3))
			(breakif '(r2 /= r3))

			;is it a compiled function ?
			(call 'hmap :search '((r0 lisp_environment) r1) '(_ r1 _))
			(breakif '(r1 = 0))
			(assign '((r1 ptr_size)) '(r1))
			(f-bind 'func :vtable r2)
			(assign '((r1 obj_vtable)) '(r3))
			(gotoif '(r2 = r3) 'bind_it)

			;is it a none compiled function ?
			(f-bind 'list :vtable r2)
			(breakif '(r2 /= r3))
			(assign '((r1 array_length)) '(r2))
			(breakif '(r2 = 0))
			(assign '((rsp local_this)) '(r0))
			(array-bind-args r1 '(r2))
			(assign '((r0 lisp_sym_lambda)) '(r3))
			(breakif '(r2 /= r3))
			(default)
			(vp-label 'bind_it)
				;bind function call site
				(assign '((rsp local_iter_begin)) '(r3))
				(class/obj/ref r1 r2)
				(assign '((r3 0) r1) '(r0 (r3 0)))
				(call 'obj :deref '(r0))
				;skip recursion on this element
				(assign '((rsp local_iter_begin)) '(r1))
				(vp-add-cr ptr_size r1)
				(goto 'skip_first)
			(endswitch)

			;loop the rest elements
			(assign '((rsp local_iter_begin)) '(r1))
		(vp-label 'skip_first)
			(assign '((rsp local_iter_end)) '(r2))
			(loop-while '(r1 /= r2))
				(assign '(r1 (r1 0)) '((rsp local_iter_begin) r1))

				(f-bind 'sym :vtable r2)
				(assign '((r1 obj_vtable)) '(r3))
				(vpif '(r2 = r3) 'next_elem)
					;is this symbol a defined constant symbol ?
					(assign '((r1 str_data ub)) '(r2))
					(breakif '(r2 /= +char_plus+))
					(assign '((rsp local_this)) '(r0))
					(call 'hmap :get '((r0 lisp_environment) r1) '(_ r1))
					(breakif '(r1 = 0))
					;yes so bind it
					(assign '((rsp local_iter_begin)) '(r2))
					(assign '((r2 0) r1) '(r0 (r2 0)))
					(call 'obj :deref '(r0))
				(else)
					;a none empty list ?
					(f-bind 'list :vtable r2)
					(breakif '(r2 /= r3))
					(assign '((r1 array_length)) '(r2))
					(breakif '(r2 = 0))
					;stack this list for scanning
					(assign '((rsp local_this)) '(r0))
					(assign '((r0 lisp_stack)) '(r0))
				(errorcases
					(assign '((r0 array_length) (rsp local_start)) '(r2 r3))
					(vp-sub-rr r3 r2)
					(vpif '(r2 >= 1000))
						(debug-str '("Exessive prebind recursion !"))
						(break 'next_elem)
					(endif))
					(call 'array :push_back '(r0 r1))
				(endif)

				(assign '((rsp local_iter_begin) (rsp local_iter_end)) '(r1 r2))
				(vp-add-cr ptr_size r1)
			(loop-end)

		(vp-label 'next_list)
			;pop next list off stack, break if empty
			(assign '((rsp local_this)) '(r0))
			(assign '((r0 lisp_stack)) '(r2))
			(assign '((rsp local_start) (r2 array_length)) '(r3 r1))
			(breakif '(r1 = r3))
			(vp-sub-cr 1 r1)
			(assign '(r1) '((r2 array_length)))
			(class/array/get_element r2 r1 r1 r2)
		(loop-end)

		(assign '((rsp local_form)) '(r1))
		(vp-free local_size)
	(endswitch)

	(exit 'lisp :repl_bind '(r0))
	(vp-ret)

(def-func-end)
